// LAB 2: SORTING AND CAMPY SCI-FI// Welcome to Lab 2 =)// Be sure to read all the comments!// All of the instructions are inline with the assignment below.// Look for the word TODO in comments.  Each TODO will have a// description of what is required.// To run this file (in the terminal) use: node lab2.js// ********************************************************// SETUP//*********************************************************// We're going to use this special assert method again to// test our codefunction assert(expression, failureMessage) {  if (!expression) {    console.log("assertion failure: ", failureMessage);  }}//*********************************************************// PROBLEM 1: The Blob. 20 points//*********************************************************/* Dowington, PA had 1000 citizens on the night the blob escaped its meteorite. At first, the blob could only find and consume Pennsylvanians at a rate of 1/hour. However, each time it digested someone, it became faster and stronger: adding to its consumption rate by 1 person/hour. persons consumed  |  rate of consumption ------------------|---------------------        0          |       1/hour        1          |       2/hour        2          |       3/hour        3          |       4/hour TODO: First, make a constructor function, called Blob, that makes blobs. TODO: Next, create an instance of Blob named blob. TODO: Then, use a loop to calculate how long it took the blob to finish with Dowington.*/function Blob(personsConsumed, rateOfConsumption) {  this.blob = "Dowington";  this.personsConsumed = personsConsumed;  this.rateOfConsumption = rateOfConsumption;  this.timeTotal = 0;}var blob = new Blob(0, 1);// for (var personsConsumed = 0; personsConsumed <= 1000; personsConsumed++) {  // blob.rateOfConsumption = 60 / (personsConsumed + 1); //returns minutes per meal  // blob.timeTotal += blob.rateOfConsumption;  // console.log([personsConsumed], [blob.rateOfConsumption], [blob.timeTotal]); // }//console.log(blob.timeTotal);for (var rateOfConsumption = 1; rateOfConsumption <= 1001 ; rateOfConsumption++) {  blob.timeTotal += (60 / rateOfConsumption);}//console.log(blob.timeTotal);var hoursSpentInDowington; // TODO: assign me the value of the                           // above calculationblob.conversions = function() {var result = (this.timeTotal / 60);var hours = Math.floor(result); //leaves only hoursvar minutesInterger = Math.floor(this.timeTotal - (hours * 60));var minutes = this.timeTotal - (hours * 60);var seconds = Math.floor((((minutes - Math.floor(minutes)) * 60) * 100) / 100);return (hours + " Hours " + minutesInterger + " minutes " + seconds + " seconds.");};var hoursSpentInDowington = blob.conversions();// console.log(hoursSpentInDowington);// console.log(blob.timeTotal);// Now, write a method that takes a population for an arbitrary// town, and the starting consumption rate, and returns the number// of hours the blob needs to ooze its way through that town.function hoursToOoze(population, peoplePerHour) {// TODO: implement me based on the instructions above. Be sure to then assign me to the Blob's prototype.var timeTotal = 0;if (peoplePerHour === 0) {  return Infinity;}if (population === 0) {  return 0;}for (var rate = peoplePerHour ; rate <= population + 1; rate++) {  timeTotal += (60 / rate);}var result = (timeTotal / 60);var hours = Math.floor(result); //leaves only hoursvar minutesInterger = Math.floor(timeTotal - (hours * 60));var minutes = timeTotal - (hours * 60);var seconds = Math.floor((((minutes - Math.floor(minutes)) * 60) * 100) / 100);return (hours + " Hours " + minutesInterger + " minutes " + seconds + " seconds.");}blob.hoursToOoze = hoursToOoze;var test = blob.hoursToOoze(1000, 1);console.log(test);assert(blob.hoursToOoze(0, 1) === 0, "no people means no time needed.");assert(blob.hoursToOoze(1000, 1) === hoursSpentInDowington,  "hoursSpentInDowington should match hoursToOoze\"s result for 1000");// TODO: write three more assertions like the two above, testing out// the hoursToOoze method.assert(blob.hoursToOoze(1000, 0) === Infinity, "That should have taken forever.");assert(blob.hoursToOoze(1000, 2) < hoursSpentInDowington, "This should take less time.");assert(blob.hoursToOoze(5000, 1) > hoursSpentInDowington, "That should take a lot longer.");//*********************************************************// PROBLEM 2: Universal Translator. 20 points//*********************************************************var hello = {  klingon: "nuqneH",  // home planet is Qo"noS  romulan: "Jolan\"tru", // home planet is Romulus  "federation standard": "hello" // home planet is Earth};// TODO: define a constructor that creates objects to represent// sentient beings. They have a home planet, a language that they// speak, and method called sayHello.function SentientBeing (homePlanet, language) {this.planet = homePlanet;this.language = language;  // TODO: specify a home planet and a language  // you'll need to add parameters to this constructor}// sb is a SentientBeing objectfunction sayHello(sb) {    // TODO: say hello prints out (console.log's) hello in the    // language of the speaker, but returns it in the language    // of the listener (the sb parameter above).    // use the 'hello' object at the beginning of this exercise    // to do the translating    //TODO: put this on the SentientBeing prototype    console.log(hello[this.language]); //speaker    return hello[sb.language]; //listener  }SentientBeing.prototype = {};SentientBeing.prototype.sayHello = sayHello;function Klingon() {  this.parent = "SentientBeing";}function Romulan() {  this.parent = "SentientBeing";}function Human() {  this.parent = "SentientBeing";}// TODO: create three subclasses of SentientBeing, one for each// species above (Klingon, Human, Romulan).Klingon.prototype = new SentientBeing("Qo\"nos", "klingon");Romulan.prototype = new SentientBeing("Romulus", "romulan");Human.prototype = new SentientBeing("Earth", "federation standard");assert((new Human()).sayHello(new Klingon()) === "nuqneH",  "the klingon should hear nuqneH");// TODO: write five more assertions, to complete all the possible// greetings between the three types of sentient beings you created above.assert((new Human()).sayHello(new Romulan()) === "Jolan\"tru",  "the romulan should hear Jolan\"tru");assert((new Romulan()).sayHello(new Klingon()) === "nuqneH",  "the klingon should hear nuqneH");assert((new Romulan()).sayHello(new Human()) === "hello",  "the human should hear hello");assert((new Klingon()).sayHello(new Romulan()) === "Jolan\"tru",  "the romulan should hear Jolan\"tru");assert((new Klingon()).sayHello(new Human()) === "hello",  "the human should hear hello");//*********************************************************// PROBLEM 3: Sorting. 20 points.//// Implement the following functions. Write at least 2// assertions for each one//*********************************************************// HOT PATCH:// implement the functions lastLetterSort, sumArray, and sumSort.// You don't have to use the .sort lines the way they're written.// Get something to work, use helper functions when needed (a.k.a. functions inside of your big function that have specific functionality),// and write at least 2 assertions to test whether your functions work.var fruit = [ "apple", "banana", "Cherry" ];var sortedFruit = [ "banana", "apple", "Cherry" ];function byLastLetter(a, b) {  if (a.split("").reverse()[0] < b.split("").reverse()[0]) {    return -1;  }  if (a.split("").reverse()[0] > b.split("").reverse()[0]) {    return 1;  }  // a must be equal to b  return 0;}function lastLetterSort(stringArray) {  // function byLastLetter(array) {    //TODO: implement me. sort the strings in alphabetical    // order using their last letter    // read this: http://www.w3schools.com/jsref/jsref_sort.asp    return stringArray.sort(byLastLetter);  // }  // stringArray.sort(byLastLetter);}assert(lastLetterSort(fruit)[0] === sortedFruit[0], "sort those fruits!");assert(lastLetterSort(fruit).length === sortedFruit.length, "not enough fruits!");// console.log(lastLetterSort(fruit));// console.log(sortedFruit);var scores = [ 1, 2, 10, 21 ];function sumArray(numberArray) {  var sum = 0;  // TODO: implement me using forEach  numberArray.forEach(function(element, index, array) {    sum += element;  });  return sum;}assert(sumArray(scores) > 21, "too small!");assert(sumArray(scores) === 34, "not 34.");console.log(sumArray(scores));var allScores = [ [ 19, 2, 101, 213 ], [ 1, 2, 10, 21 ], [ 11, 3, 11, 211 ] ];function sumSort(arrayOfArrays) {  return arrayOfArrays.sort(function(a, b) {    // TODO: implement me using sumArray    //  order the arrays based on the sum of the numbers    //  inside each array    if (sumArray(a) < sumArray(b)) {    return -1;  }  if (sumArray(a) > sumArray(b)) {    return 1;  }  // a must be equal to b  return 0;  });}assert(sumSort(allScores)[0][3] === 21, "or it'll be the other...");assert(sumSort(allScores)[1][3] === 211, "or it'll be the other...");//*********************************************************// PROBLEM 4: Cleanup: 10 points// Makes sure this file passes jshint and jscs//// ./node_modules/.bin/grunt jshint// ./node_modules/.bin/grunt jscs//*********************************************************